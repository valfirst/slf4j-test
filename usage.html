<!DOCTYPE html>


<!--
 | Generated by Apache Maven Doxia Site Renderer 1.11.1 from src/site/markdown/usage.md at 2023-07-11
 | Rendered using Apache Maven Fluido Skin 1.11.1
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.11.1" />
    <title>SLF4J Test &#x2013; Usage</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-1.11.1.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
    <script src="./js/apache-maven-fluido-1.11.1.min.js"></script>
    <!-- Google Analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
       (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-15938495-2', 'auto');
      ga('send', 'pageview');
      ga('set', 'anonymizeIp', true);
      ga('set', 'forceSSL', true);
    </script>
  </head>
  <body class="topBarDisabled">
    <a class="github-fork-ribbon right-top" href="https://github.com/valfirst/slf4j-test" data-ribbon="Fork me on GitHub" title="Fork me on GitHub">Fork me on GitHub</a>
    <div class="container-fluid">
      <header>
        <div id="banner">
          <div class="pull-left"><div id="bannerLeft"><h1>SLF4J Test</h1>
</div>
</div>
          <div class="pull-right"></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
        <li id="publishDate">Last Published: 2023-07-11<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 3.0.0</li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">Overview</li>
    <li><a href="index.html" title="Introduction"><span class="none"></span>Introduction</a></li>
    <li class="active"><a><span class="none"></span>Usage</a></li>
    <li><a href="changelog.html" title="Changelog"><span class="none"></span>Changelog</a></li>
   <li class="nav-header">Project Documentation</li>
    <li><a href="project-info.html" title="Project Information"><span class="icon-chevron-right"></span>Project Information</a></li>
    <li><a href="project-reports.html" title="Project Reports"><span class="icon-chevron-right"></span>Project Reports</a></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
<a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy"><img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn"  class="span10" >
<section>
<h2><a name="Usage"></a>Usage</h2><section>
<h3><a name="Making_Assertions"></a>Making Assertions</h3>
<p>TestLoggerFactory is the underlying implementation to which SLF4J's
LoggerFactory delegates when SLF4J Test is the bound SLF4J implementation. The
getLogger method on TestLoggerFactory returns the same Logger instance as that
on LoggerFactory, but with the additional type information to allow retrieval of
the LoggingEvents that have occurred against that Logger.</p>
<p>SLF4J Test provides a comprehensive set of static factory methods on
LoggingEvent to facilitate easy construction of expected events for comparison
against those that were actually received, and LoggingEvent has appropriate
equals, hashCode and toString implementations for this purpose. See the <a href="./index.html">front
</a> page for an example of using the <a href="./xref/com/github/valfirst/slf4jtest/LoggingEvent.html#L161">info static factory method
</a> to create an expected
LoggingEvent.</p><section>
<h4><a name="Custom_Predicates"></a>Custom Predicates</h4>
<p>Users can provide custom predicates so that they can assert on <code>LoggingEvent</code>s in specific ways in addition to the regular supported ways.</p>
<p><i>Example:</i></p>

<div class="source"><pre class="prettyprint linenums"><code>assertThat(logger)
    .hasLogged(event -&gt; event.getFormattedMessage().startsWith(&quot;First section of long log message&quot;));
</code></pre></div></section><section>
<h4><a name="MDC_Comparison_Strategy"></a>MDC Comparison Strategy</h4>
<p>The default behaviour requires the MDC contents to match exactly. But since the full MDC context isn't always relevant to the test, the MDC comparison strategy can be specified by users.</p>
<p><i>Example:</i></p>

<div class="source"><pre class="prettyprint linenums"><code>assertThat(logger)
    .usingMdcComparator(MdcComparator.IGNORING)
    .hasLogged(warn(&quot;Some log message&quot;));
</code></pre></div></section></section><section>
<h3><a name="Setting_the_Log_Level_on_a_Logger"></a>Setting the Log Level on a Logger</h3>
<p>SLF4J Test only stores events for levels which are marked as enabled on the
Logger. By default, all levels are enabled; however, this can be programmatically
changed on a per logger basis using the following functions:</p>

<div class="source"><pre class="prettyprint linenums"><code>Logger.setEnabledLevels(Level... levels)
Logger.setEnabledLevelsForAllThreads(Level... levels)
</code></pre></div>
<p>It's important to note that SLF4J does <i>not</i> imply any relationship between the
levels - it is perfectly possible for a logger to be enabled for INFO but
disabled for ERROR as far as SLF4J is concerned, and hence as far as SLF4J Test
is concerned, notwithstanding the fact that implementations such as Logback and
Log4J do not permit this.</p></section><section>
<h3><a name="Globally_disabling_a_Log_Level"></a>Globally disabling a Log Level</h3>
<p>Storing log events at all levels can slow down test executions. If needed a global
setting can be used to avoid capturing events at a given level or below respecting
the conventional level hierarchy (if the capture level is set to INFO, DEBUG and TRACE
events won't be captured). This can be set in any of the following ways:</p><section>
<h4><a name="Programmatically"></a>Programmatically</h4>

<div class="source"><pre class="prettyprint linenums"><code>TestLoggerFactory.getInstance().setCaptureLevel(Level.INFO);
</code></pre></div></section><section>
<h4><a name="Via_a_System_Property"></a>Via a System Property</h4>
<p>Run the JVM with the following:</p>

<div class="source"><pre class="prettyprint linenums"><code>-Dslf4jtest.capture.level=INFO
</code></pre></div></section><section>
<h4><a name="Via_a_properties_file"></a>Via a properties file</h4>
<p>Place a file called slf4jtest.properties on the classpath with the following
line in it:</p>

<div class="source"><pre class="prettyprint linenums"><code>capture.level=INFO
</code></pre></div></section></section><section>
<h3><a name="Resetting_Stored_State"></a>Resetting Stored State</h3>
<p>In order to have robust tests the in memory state of SLF4J Test must be in a
known state for each test run, which in turn implies that a test should clean up
after itself. The simplest way to do so is via a call to</p>

<div class="source"><pre class="prettyprint linenums"><code class="language-java">TestLoggerFactory.clear()
</code></pre></div>
<p>in a tear down method of some kind.</p>
<p>More nuanced state resetting can be done on a per logger basis:</p>

<div class="source"><pre class="prettyprint linenums"><code class="language-java">TestLogger.clear()
</code></pre></div>
<p>or more aggressive clears will reset state across all threads:</p>

<div class="source"><pre class="prettyprint linenums"><code class="language-java">TestLoggerFactory.clearAll()
TestLogger.clearAll()
</code></pre></div><section>
<h4><a name="JUnit_4"></a>JUnit 4</h4>
<p>If you are using JUnit 4 then SLF4J Test provides a <code>@Rule</code> that will do this
for you if you provide the following line in your test class:</p>

<div class="source"><pre class="prettyprint linenums"><code class="language-java">@Rule public TestRule resetLoggingEvents = new TestLoggerFactoryResetRule();
</code></pre></div></section><section>
<h4><a name="JUnit_5"></a>JUnit 5</h4>
<p>SLF4J Test provides JUnit Platform extension which can be registered in any supported way.</p><section>
<h5><a name="Declarative_Extension_Registration"></a>Declarative Extension Registration</h5>
<p><code>TestLoggerFactoryExtension</code> can be registered declaratively via <code>@ExtendWith</code> annotation:</p>

<div class="source"><pre class="prettyprint linenums"><code class="language-java">import org.junit.jupiter.api.extension.ExtendWith;
import com.github.valfirst.slf4jtest.TestLoggerFactoryExtension;

@ExtendWith(TestLoggerFactoryExtension.class)
class BasicJUnit5Test {
    ...
}
</code></pre></div>
<p>It is possible to configure stage which cleanup should be performed at
using <code>@TestLoggerFactorySettings</code> annotation:</p>

<div class="source"><pre class="prettyprint linenums"><code class="language-java">import org.junit.jupiter.api.extension.ExtendWith;
import com.github.valfirst.slf4jtest.CleanupStage;
import com.github.valfirst.slf4jtest.TestLoggerFactoryExtension;
import com.github.valfirst.slf4jtest.TestLoggerFactorySettings;

@ExtendWith(TestLoggerFactoryExtension.class)
@TestLoggerFactorySettings(cleanupStage = CleanupStage.BEFORE_EACH)
class BasicJUnit5Test {
    ...
}
</code></pre></div></section><section>
<h5><a name="Programmatic_Extension_Registration"></a>Programmatic Extension Registration</h5>
<p><code>TestLoggerFactoryExtension</code> can be registered programmatically by annotating field in test classes
with <code>@RegisterExtension</code>:</p>

<div class="source"><pre class="prettyprint linenums"><code class="language-java">import org.junit.jupiter.api.extension.RegisterExtension;
import com.github.valfirst.slf4jtest.TestLoggerFactoryExtension;

class BasicJUnit5Test {

    @RegisterExtension
    static TestLoggerFactoryExtension extension = new TestLoggerFactoryExtension();
    ...
}
</code></pre></div>
<p>Also, it is possible to configure stage which clean up should happen at:</p>

<div class="source"><pre class="prettyprint linenums"><code class="language-java">import org.junit.jupiter.api.extension.RegisterExtension;
import com.github.valfirst.slf4jtest.CleanupStage;
import com.github.valfirst.slf4jtest.TestLoggerFactoryExtension;

class BasicJUnit5Test {

    @RegisterExtension
    static TestLoggerFactoryExtension extension = new TestLoggerFactoryExtension(CleanupStage.BEFORE_EACH);
   ...
}
</code></pre></div></section><section>
<h5><a name="Automatic_Extension_Registration"></a>Automatic Extension Registration</h5>
<p>SLF4J Test supports automatic extension registration via ServiceLoader mechanism.
This feature is considered advanced in JUnit Platform and
<a class="externalLink" href="https://junit.org/junit5/docs/current/user-guide/#extensions-registration-automatic-enabling">it requires explicit enabling</a>.</p></section></section></section><section>
<h3><a name="Parallel_Testing"></a>Parallel Testing</h3>
<p>SLF4J Test is designed to facilitate tests run in parallel. Because SLF4J
Loggers are commonly shared across threads, the SLF4J Test implementation
maintains its state in ThreadLocals. The following functions:</p>

<div class="source"><pre class="prettyprint linenums"><code>TestLogger.getLoggingEvents()
TestLogger.clear()
TestLogger.getEnabledLevels()
TestLogger.setEnabledLevels(Level... levels)
TestLoggerFactory.getLoggingEvents()
TestLoggerFactory.clear()
</code></pre></div>
<p>all only affect state stored in a ThreadLocal, and thus tests which use them can
safely be parallelised without any danger of concurrent test runs affecting each
other.</p></section><section>
<h3><a name="Testing_Multiple_Threads_Logging"></a>Testing Multiple Threads Logging</h3>
<p>At times, however, it may be desirable to assert about the log messages produced
by concurrent code. To facilitate this SLF4J Test also maintains a record of
logging events from <i>all</i> threads. This state can be accessed and reset using
the following functions:</p>

<div class="source"><pre class="prettyprint linenums"><code>TestLogger.getAllLoggingEvents()
TestLogger.clearAll()
TestLogger.setEnabledLevelsForAllThreads(Level... levels)
TestLoggerFactory.getAllLoggingEvents()
TestLoggerFactory.clearAll()
</code></pre></div></section><section>
<h3><a name="Printing_log_statements_to_System_out_and_err"></a>Printing log statements to System out and err</h3>
<p>It can still be useful to print log messages to System out/err as appropriate.
SLF4J Test will print messages using a standard (non-configurable) format based
on the value of the TestLoggerFactory's printLevel property. For convenience
this does respect the conventional level hierarchy where if the print level is
INFO logging events at levels WARN and ERROR will also be printed. A level that is
disabled <a href="#globally-disabling-a-log-level">globally</a> will not be printed.</p>
<p>This can be set in any of the following ways:</p><section>
<h4><a name="Programmatically"></a>Programmatically</h4>

<div class="source"><pre class="prettyprint linenums"><code>TestLoggerFactory.getInstance().setPrintLevel(Level.INFO);
</code></pre></div></section><section>
<h4><a name="Via_a_System_Property"></a>Via a System Property</h4>
<p>Run the JVM with the following:</p>

<div class="source"><pre class="prettyprint linenums"><code>-Dslf4jtest.print.level=INFO
</code></pre></div></section><section>
<h4><a name="Via_a_properties_file"></a>Via a properties file</h4>
<p>Place a file called slf4jtest.properties on the classpath with the following
line in it:</p>

<div class="source"><pre class="prettyprint linenums"><code>print.level=INFO
</code></pre></div></section></section><section>
<h3><a name="Testing_Code_Using_java.util.logging"></a>Testing Code Using java.util.logging</h3>
<p>Although this module is named SLF4J Test, it can be used to test code using
other test API's as well. In most cases, it is just a matter of placing the
proper bridge on the test classpath, see e.g.
<a class="externalLink" href="https://www.slf4j.org/legacy.html">Bridging legacy APIs</a>.
But in case of java.util.logging, there is a little more work than adding
<code>jul-to-slf4j</code> to the classpath. Normally,
an application will create a <code>logging.properties</code> file containing</p>

<div class="source"><pre class="prettyprint linenums"><code>handlers = org.slf4j.bridge.SLF4JBridgeHandler
</code></pre></div>
<p>and set the system property <code>java.util.logging.config.file</code> on the
command line to the full path of the file. But this is not
practical for running unit tests. Instead, the configuration is done
programmatically in the test code.</p>
<p>SLF4J Test has code to make this easier. Calling
<a href="apidocs/com/github/valfirst/slf4jtest/JulConfig.html#setup--"><code>JulConfig.setup()</code></a>
will do this for you. You should call this method before running any
test that requires java.util.logging to be configured. Calling this method more
than once has no effect, so you can safely call it before tests in all test
suites with this requirement, e.g. in a <code>@BeforeClass</code> method if using Junit 4.</p>
<p>If you use Junit 5, it is even easier. There is a Junit 5 extension
<a href="apidocs/apidocs/com/github/valfirst/slf4jtest/JulConfigExtension.html.html"><code>JulConfigExtension</code></a>
doing this declaratively. For example</p>

<div class="source"><pre class="prettyprint linenums"><code>import com.github.valfirst.slf4jtest.JulConfigExtension;
import org.junit.jupiter.api.extension.ExtendWith;

@ExtendWith(JulConfigExtension.class)
class JulLoggingTests {
    @Test
    void testJulLogging() {
        ...
    }
    ...
}
</code></pre></div></section><section>
<h3><a name="Customizing_the_MDC"></a>Customizing the MDC</h3>
<p>The MDC (original meaning Mapped Diagnostic Context) is a place that can
be used to store additional information as key/value pairs. The
information is stored by thread. It can be set by the client code and used
by the logging backend.
The <a class="externalLink" href="https://www.slf4j.org/apidocs/org/slf4j/MDC.html">specification</a> of
the MDC in SLF4J leaves much detail up to the logging backend.</p>
<p>SLF4J Test lets the user customize the behavior of the MDC to more closely
match that of the backend expected to be used at run-time.</p>
<p>The configuration can be changed in the property file <code>slf4jtest.properties</code>,
using system properties specified as command line arguments to the JVM,
or programmatically. The property file and the system properties are read
at start-up time, with system properties overriding the property file.
Note that changing the values programmatically affects all threads.</p><section>
<h4><a name="Completely_Disable_the_MDC"></a>Completely Disable the MDC</h4>
<p>The backend does not even have to implement the MDC at all.
If the log4j2 adapter or logback is used, there is full support for the MDC.
Using the java.util.logging adapter, there is an MDC, but it cannot be used
by log appenders.
In the slf4j-simple, the MDC implementation is a no-op.</p>
<p>It is possible to disable the MDC completely by specifying</p><section>
<h5><a name="Programmatically"></a>Programmatically</h5>

<div class="source"><pre class="prettyprint linenums"><code>TestMDCAdapter.getInstance().setEnable(false);
</code></pre></div></section><section>
<h5><a name="Via_a_System_Property"></a>Via a System Property</h5>

<div class="source"><pre class="prettyprint linenums"><code>-Dslf4jtest.mdc.enable=false
</code></pre></div></section><section>
<h5><a name="In_the_slf4j.properties_File"></a>In the slf4j.properties File</h5>

<div class="source"><pre class="prettyprint linenums"><code>mdc.enable=false
</code></pre></div>
<p>The default value is <code>true</code>. If disabled, the <code>get</code> and <code>getCopyOfContextMap</code>
methods return null, and all other methods are no-ops.</p></section></section><section>
<h4><a name="Inheritance_from_the_Parent_Thread"></a>Inheritance from the Parent Thread</h4>
<p>It is unspecified whether a child thread inherits the MDC from its parent.
In log4j2 and logback, the MDC is not inherited by default, but this
behavoir can be changed by the configuration. Using the java.util.logging
adapter, inheritance is always on.</p><section>
<h5><a name="Programmatically"></a>Programmatically</h5>

<div class="source"><pre class="prettyprint linenums"><code>TestMDCAdapter.getInstance().setInherit(true);
</code></pre></div></section><section>
<h5><a name="Via_a_System_Property"></a>Via a System Property</h5>

<div class="source"><pre class="prettyprint linenums"><code>-Dslf4jtest.mdc.inherit=true
</code></pre></div></section><section>
<h5><a name="In_the_slf4j.properties_File"></a>In the slf4j.properties File</h5>

<div class="source"><pre class="prettyprint linenums"><code>mdc.inherit=true
</code></pre></div>
<p>The default value is <code>false</code>.</p></section></section><section>
<h4><a name="Allow_null_values"></a>Allow null values</h4>
<p>In the description of the
<a class="externalLink" href="https://www.slf4j.org/apidocs/org/slf4j/MDC.html#put-java.lang.String-java.lang.String-"><code>put</code></a>
method, it says &#x201c;The <code>val</code> parameter can be null only if the underlying
implementation supports it.&#x201d;
To emulate a backend that does not support null values, this can be configured.</p><section>
<h5><a name="Programmatically"></a>Programmatically</h5>

<div class="source"><pre class="prettyprint linenums"><code>TestMDCAdapter.getInstance().setAllowNullValues(false);
</code></pre></div></section><section>
<h5><a name="Via_a_System_Property"></a>Via a System Property</h5>

<div class="source"><pre class="prettyprint linenums"><code>-Dslf4jtest.mdc.allow.null.values=false
</code></pre></div></section><section>
<h5><a name="In_the_slf4j.properties_File"></a>In the slf4j.properties File</h5>

<div class="source"><pre class="prettyprint linenums"><code>mdc.allow.null.values=false
</code></pre></div>
<p>The default value is <code>true</code>.
Note that if the MDC functionality has been completely disabled, null
values are accepted and ignored, regardless of this setting.</p></section></section><section>
<h4><a name="Null_Returned_for_Empty_Map"></a>Null Returned for Empty Map</h4>
<p>The description of the
<a class="externalLink" href="https://www.slf4j.org/apidocs/org/slf4j/MDC.html#getCopyOfContextMap--"><code>getCopyOfContextMap</code></a>
method says &#x201c;Returned value may be null.&#x201d;, but it is not specified under
which circumstances it may be null. Obviously, a backend that does not
support an MDC will return null. The implementation in the
java.util.logging adapter returns null, if <code>put</code> has not been called.
Other implementations may return an empty map in that case.
To change the behavior:</p><section>
<h5><a name="Programmatically"></a>Programmatically</h5>

<div class="source"><pre class="prettyprint linenums"><code>TestMDCAdapter.getInstance().setReturnNullCopyWhenMdcNotSet(true);
</code></pre></div></section><section>
<h5><a name="Via_a_System_Property"></a>Via a System Property</h5>

<div class="source"><pre class="prettyprint linenums"><code>-Dslf4jtest.mdc.return.null.copy.when.mdc.not.set=true
</code></pre></div></section><section>
<h5><a name="In_the_slf4j.properties_File"></a>In the slf4j.properties File</h5>

<div class="source"><pre class="prettyprint linenums"><code>mdc.return.null.copy.when.mdc.not.set=true
</code></pre></div>
<p>The default value is <code>false</code>, in which case an empty map is returned
when the MDC is not set.
Note that if the MDC functionality has been completely disabled,
<code>null</code> is returned, regardless of this setting.</p></section></section><section>
<h4><a name="Restoring_Options"></a>Restoring Options</h4>
<p>To restore these options to the values defined by the initial
configuration, use</p>

<div class="source"><pre class="prettyprint linenums"><code>TestMDCAdapter.getInstance().restoreOptions();
</code></pre></div></section></section><section>
<h3><a name="Using_the_Fluent_API"></a>Using the Fluent API</h3>
<p>From SLF4J version 2.0, there is a new fluent logging API.
It allows writing code like</p>

<div class="source"><pre class="prettyprint linenums"><code>logger.atInfo().setMessage(&quot;With an argument {}&quot;)
    .addArgument(() -&gt; myObj.calculateValue())
    .addMarker(&quot;ForYourEyesOnly&quot;).log();
</code></pre></div>
<p>The <code>atInfo()</code> method returns a <code>LoggingEventBuilder</code> which is used to
build the event and finally log it.</p>
<p>If logging at INFO level is not enabled, a NOOP <code>LoggingEventBuilder</code> is
returned by <code>atInfo</code>. This means the lambda on the second line will not be
executed, thus saving the overhead if the message is not logged.</p>
<p>Note that it is possible to add multiple markers to an event,
which is not possible with the classic API.</p>
<p>SLF4J Test uses the <code>TestLoggingEventBuilder</code>, which is a modified version of
the <code>DefaultLoggingEventBuilder</code> of SLF4J.</p>
<p>Creating an SLF4J Test <code>LoggingEvent</code> to compare against can be done
in the classic way like</p>

<div class="source"><pre class="prettyprint linenums"><code>LoggingEvent.info(
    MarkerFactory.getMarker(&quot;ForYourEyesOnly&quot;),
    &quot;With an argument {}&quot;,
    myObj.calculateValue());
</code></pre></div>
<p>Alternatively, you can create the <code>LoggingEvent</code> from an existing SLF4J
logging event, like</p>

<div class="source"><pre class="prettyprint linenums"><code>LoggingEvent.fromSlf4jEvent(
    new TestLoggingEventBuilder(null, Level.INFO)
        .setMessage(&quot;With an argument {}&quot;)
        .addArgument(() -&gt; myObj.calculateValue())
        .addMarker(MarkerFactory.getMarker(&quot;ForYourEyesOnly&quot;))
        .toLoggingEvent());
</code></pre></div>
<p>This approach is necessary if you use the features available
in the fluent API only. This includes multiple markers and key/value pairs.</p>
<p>The <code>TestLoggingEventBuilder</code> adds the <code>toLoggingEvent</code> method
to access the created event. Please note that the returned value is an
<code>org.slf4j.event.LoggingEvent</code>,
which is different from <code>com.github.valfirst.slf4jtest.LoggingEvent</code>.</p></section></section>
        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>&#169;      2023
</p>
        </div>
      </div>
    </footer>
<script>
	if(anchors) {
	  anchors.add();
	}
</script>
  </body>
</html>