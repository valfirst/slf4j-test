<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TestLoggerAssert.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">SLF4J Test</a> &gt; <a href="index.source.html" class="el_package">com.github.valfirst.slf4jtest</a> &gt; <span class="el_source">TestLoggerAssert.java</span></div><h1>TestLoggerAssert.java</h1><pre class="source lang-java linenums">package com.github.valfirst.slf4jtest;

import java.util.*;
import java.util.function.BiPredicate;
import java.util.function.Predicate;
import org.slf4j.Marker;
import org.slf4j.event.KeyValuePair;
import org.slf4j.event.Level;

/**
 * A set of assertions to validate that logs have been logged to a {@link TestLogger}.
 *
 * &lt;p&gt;Should be thread safe, as this uses &lt;code&gt;testLogger.getLoggingEvents()&lt;/code&gt; by default. The
 * assertion mode can be switched to use &lt;code&gt;testLogger.getAllLoggingEvents()&lt;/code&gt; by calling
 * {@link #anyThread()}.
 */
public class TestLoggerAssert extends AbstractTestLoggerAssert&lt;TestLoggerAssert&gt; {

<span class="fc" id="L19">    private MdcComparator mdcComparator = MdcComparator.EXACT;</span>

    protected TestLoggerAssert(TestLogger testLogger) {
<span class="fc" id="L22">        super(testLogger, TestLoggerAssert.class);</span>
<span class="fc" id="L23">    }</span>

    /**
     * Changes the assertion mode to verify that log messages have been logged regardless of which
     * thread actually logged the message.
     *
     * @return a {@link TestLoggerAssert} for chaining
     */
    public TestLoggerAssert anyThread() {
<span class="fc" id="L32">        loggingEventsSupplier = actual::getAllLoggingEvents;</span>
<span class="fc" id="L33">        return this;</span>
    }

    /**
     * Allows the comparison strategy for verifying the MDC contents to be configured.
     *
     * &lt;p&gt;The default behaviour is to verify the contents of the MDC are exactly equal to those on the
     * logging event.
     *
     * @param mdcComparator the comparator to use when verifying the contents of the MDC captured by
     *     the logging event
     * @return a {@link TestLoggerAssert} for chaining
     * @see MdcComparator
     */
    public TestLoggerAssert usingMdcComparator(MdcComparator mdcComparator) {
<span class="fc" id="L48">        this.mdcComparator = mdcComparator;</span>
<span class="fc" id="L49">        return this;</span>
    }

    /**
     * Verify that a log message, at a specific level, has been logged by the test logger.
     *
     * @param level the level of the log message to look for
     * @param message the expected message
     * @param arguments any optional arguments that may be provided to the log message
     * @return a {@link TestLoggerAssert} for chaining
     */
    public TestLoggerAssert hasLogged(Level level, String message, Object... arguments) {
<span class="fc" id="L61">        return hasLogged(event(level, message, arguments));</span>
    }

    /**
     * Verify that a log message, at a specific level, has been logged by the test logger in the
     * presence of a {@link Throwable}.
     *
     * @param throwable the throwable that is attached to the log message
     * @param level the level of the log message to look for
     * @param message the expected message
     * @param arguments any optional arguments that may be provided to the log message
     * @return a {@link TestLoggerAssert} for chaining
     */
    public TestLoggerAssert hasLogged(
            Throwable throwable, Level level, String message, Object... arguments) {
<span class="fc" id="L76">        return hasLogged(event(throwable, level, message, arguments));</span>
    }

    /**
     * Verify that a {@link LoggingEvent} has been logged by the test logger.
     *
     * @param event the event to verify presence of
     * @return a {@link TestLoggerAssert} for chaining
     */
    public TestLoggerAssert hasLogged(LoggingEvent event) {
<span class="fc" id="L86">        return hasLogged(buildPredicate(event), &quot;Failed to find event:%n  %s&quot;, event);</span>
    }

    /**
     * Verify that a {@link LoggingEvent} satisfying the provided predicate has been logged by the
     * test logger.
     *
     * @param predicate the predicate to test against
     * @return a {@link TestLoggerAssert} for chaining
     */
    public TestLoggerAssert hasLogged(Predicate&lt;LoggingEvent&gt; predicate) {
<span class="fc" id="L97">        return hasLogged(predicate, &quot;Failed to find log matching predicate&quot;);</span>
    }

    /**
     * Uses the supplied {@link PredicateBuilder} to construct the predicate with which to Verify that
     * a matching {@link LoggingEvent} has been logged by the test logger.
     *
     * @param predicate the {@link PredicateBuilder} to use to construct the test predicate
     * @return a {@link TestLoggerAssert} for chaining
     */
    public TestLoggerAssert hasLogged(PredicateBuilder predicate) {
<span class="fc" id="L108">        return hasLogged(predicate.build());</span>
    }

    /**
     * Verify that a log message, at a specific level, has not been logged by the test logger.
     *
     * @param level the level of the log message to look for
     * @param message the expected message
     * @param arguments any optional arguments that may be provided to the log message
     * @return a {@link TestLoggerAssert} for chaining
     */
    public TestLoggerAssert hasNotLogged(Level level, String message, Object... arguments) {
<span class="fc" id="L120">        return hasNotLogged(event(level, message, arguments));</span>
    }

    /**
     * Verify that a log message, at a specific level, has not been logged by the test logger in the
     * presence of a {@link Throwable}.
     *
     * @param throwable the throwable that is attached to the log message
     * @param level the level of the log message to look for
     * @param message the expected message
     * @param arguments any optional arguments that may be provided to the log message
     * @return a {@link TestLoggerAssert} for chaining
     */
    public TestLoggerAssert hasNotLogged(
            Throwable throwable, Level level, String message, Object... arguments) {
<span class="fc" id="L135">        return hasNotLogged(event(throwable, level, message, arguments));</span>
    }

    /**
     * Verify that a {@link LoggingEvent} has not been logged by the test logger.
     *
     * @param event the event to verify absence of
     * @return a {@link TestLoggerAssert} for chaining
     */
    public TestLoggerAssert hasNotLogged(LoggingEvent event) {
<span class="fc" id="L145">        return hasNotLogged(buildPredicate(event));</span>
    }

    /**
     * Verify that a {@link LoggingEvent} satisfying the provided predicate has _not_ been logged by
     * the test logger.
     *
     * @param predicate the predicate to test against
     * @return a {@link TestLoggerAssert} for chaining
     */
    public TestLoggerAssert hasNotLogged(Predicate&lt;LoggingEvent&gt; predicate) {
<span class="fc" id="L156">        findEvent(predicate)</span>
<span class="fc" id="L157">                .ifPresent(</span>
                        loggingEvent -&gt;
<span class="nc" id="L159">                                failWithMessage(&quot;Found %s, even though we expected not to&quot;, loggingEvent));</span>

<span class="fc" id="L161">        return this;</span>
    }

    /**
     * Uses the supplied {@link PredicateBuilder} to construct the predicate with which to Verify that
     * a matching {@link LoggingEvent} has _not_ been logged by the test logger.
     *
     * @param predicate the {@link PredicateBuilder} to use to construct the test predicate
     * @return a {@link TestLoggerAssert} for chaining
     */
    public TestLoggerAssert hasNotLogged(PredicateBuilder predicate) {
<span class="fc" id="L172">        findEvent(predicate.build())</span>
<span class="fc" id="L173">                .ifPresent(</span>
                        loggingEvent -&gt;
<span class="nc" id="L175">                                failWithMessage(&quot;Found %s, even though we expected not to&quot;, loggingEvent));</span>

<span class="fc" id="L177">        return this;</span>
    }

    /**
     * Convenience method for a {@link LevelAssert} from a provided test logger.
     *
     * @param level the {@link Level} to assert against
     * @return the {@link LevelAssert} bound to the given {@link Level}
     */
    public LevelAssert hasLevel(Level level) {
<span class="fc" id="L187">        LevelAssert levelAssert = new LevelAssert(actual, level);</span>
<span class="fc" id="L188">        levelAssert.loggingEventsSupplier = loggingEventsSupplier;</span>
<span class="fc" id="L189">        return levelAssert;</span>
    }

    private TestLoggerAssert hasLogged(
            Predicate&lt;LoggingEvent&gt; predicate, String failureMessage, Object... arguments) {
<span class="fc bfc" id="L194" title="All 2 branches covered.">        if (!findEvent(predicate).isPresent()) {</span>
<span class="fc" id="L195">            String allEvents =</span>
<span class="fc" id="L196">                    loggingEventsSupplier.get().stream()</span>
<span class="fc" id="L197">                            .map(Objects::toString)</span>
<span class="fc" id="L198">                            .reduce((first, second) -&gt; first + &quot;\n  - &quot; + second)</span>
<span class="fc" id="L199">                            .map(output -&gt; &quot;  - &quot; + output)</span>
<span class="fc" id="L200">                            .orElse(&quot;  &lt;none&gt;&quot;);</span>
<span class="fc" id="L201">            Object[] newArguments = Arrays.copyOf(arguments, arguments.length + 1);</span>
<span class="fc" id="L202">            newArguments[arguments.length] = allEvents;</span>
<span class="nc" id="L203">            failWithMessage(</span>
                    failureMessage + &quot;%n%nThe logger contained the following events:%n%s&quot;, newArguments);
        }
<span class="fc" id="L206">        return this;</span>
    }

    private Predicate&lt;LoggingEvent&gt; buildPredicate(LoggingEvent event) {
<span class="fc" id="L210">        return new PredicateBuilder()</span>
<span class="fc" id="L211">                .withMarkers(event.getMarkers().toArray(new Marker[0]))</span>
<span class="fc" id="L212">                .withKeyValuePairs(event.getKeyValuePairs().toArray(new KeyValuePair[0]))</span>
<span class="fc" id="L213">                .withThrowable(event.getThrowable().orElse(null))</span>
<span class="fc" id="L214">                .withLevel(event.getLevel())</span>
<span class="fc" id="L215">                .withMessage(event.getMessage())</span>
<span class="fc" id="L216">                .withArguments(event.getArguments().toArray())</span>
<span class="fc" id="L217">                .withMdc(event.getMdc(), mdcComparator)</span>
<span class="fc" id="L218">                .build();</span>
    }

    private Optional&lt;LoggingEvent&gt; findEvent(Predicate&lt;LoggingEvent&gt; predicate) {
<span class="fc" id="L222">        return loggingEventsSupplier.get().stream().filter(predicate).findFirst();</span>
    }

<span class="fc" id="L225">    public static class PredicateBuilder {</span>

<span class="fc" id="L227">        private static final Predicate&lt;LoggingEvent&gt; IGNORE_PREDICATE = event -&gt; true;</span>

<span class="fc" id="L229">        private Predicate&lt;LoggingEvent&gt; messagePredicate = IGNORE_PREDICATE;</span>
<span class="fc" id="L230">        private Predicate&lt;LoggingEvent&gt; argumentsPredicate = IGNORE_PREDICATE;</span>
<span class="fc" id="L231">        private Predicate&lt;LoggingEvent&gt; markerPredicate = IGNORE_PREDICATE;</span>
<span class="fc" id="L232">        private Predicate&lt;LoggingEvent&gt; keyValuePairsPredicate = IGNORE_PREDICATE;</span>
<span class="fc" id="L233">        private Predicate&lt;LoggingEvent&gt; mdcPredicate = IGNORE_PREDICATE;</span>
<span class="fc" id="L234">        private Predicate&lt;LoggingEvent&gt; throwablePredicate = IGNORE_PREDICATE;</span>
<span class="fc" id="L235">        private Predicate&lt;LoggingEvent&gt; levelPredicate = IGNORE_PREDICATE;</span>

        public static PredicateBuilder aLog() {
<span class="fc" id="L238">            return new PredicateBuilder();</span>
        }

        public PredicateBuilder withLevel(Level level) {
<span class="fc" id="L242">            levelPredicate = event -&gt; event.getLevel().equals(level);</span>
<span class="fc" id="L243">            return this;</span>
        }

        /**
         * @deprecated There can be more than one marker in a logging event. Use {@link #withMarkers}
         *     instead.
         */
        @Deprecated
        public PredicateBuilder withMarker(Marker marker) {
<span class="fc bfc" id="L252" title="All 2 branches covered.">            return withMarkers(marker == null ? new Marker[] {} : new Marker[] {marker});</span>
        }

        public PredicateBuilder withMarkers(Marker... markers) {
<span class="fc" id="L256">            markerPredicate = event -&gt; event.getMarkers().equals(Arrays.asList(markers));</span>
<span class="fc" id="L257">            return this;</span>
        }

        public PredicateBuilder withKeyValuePairs(KeyValuePair... keyValuePair) {
<span class="fc" id="L261">            keyValuePairsPredicate =</span>
<span class="fc" id="L262">                    event -&gt; event.getKeyValuePairs().equals(Arrays.asList(keyValuePair));</span>
<span class="fc" id="L263">            return this;</span>
        }

        public PredicateBuilder withMessage(String message) {
<span class="fc" id="L267">            return withMessage(message::equals);</span>
        }

        public PredicateBuilder withMessage(Predicate&lt;String&gt; predicate) {
<span class="fc" id="L271">            this.messagePredicate = event -&gt; predicate.test(event.getMessage());</span>
<span class="fc" id="L272">            return this;</span>
        }

        public PredicateBuilder withArguments(Object... arguments) {
<span class="fc" id="L276">            return withArguments(actualArgs -&gt; actualArgs.equals(Arrays.asList(arguments)));</span>
        }

        public PredicateBuilder withArguments(Predicate&lt;Collection&lt;Object&gt;&gt; predicate) {
<span class="fc" id="L280">            this.argumentsPredicate = event -&gt; predicate.test(event.getArguments());</span>
<span class="fc" id="L281">            return this;</span>
        }

        public PredicateBuilder withThrowable(Throwable throwable) {
<span class="fc" id="L285">            return withThrowable(t -&gt; t.equals(Optional.ofNullable(throwable)));</span>
        }

        public PredicateBuilder withThrowable(Predicate&lt;Optional&lt;Throwable&gt;&gt; predicate) {
<span class="fc" id="L289">            this.throwablePredicate = event -&gt; predicate.test(event.getThrowable());</span>
<span class="fc" id="L290">            return this;</span>
        }

        public PredicateBuilder withMdc(Map&lt;String, String&gt; mdc, MdcComparator comparator) {
<span class="fc" id="L294">            this.mdcPredicate = event -&gt; comparator.compare(event.getMdc(), mdc);</span>
<span class="fc" id="L295">            return this;</span>
        }

        public Predicate&lt;LoggingEvent&gt; build() {
<span class="fc" id="L299">            return levelPredicate</span>
<span class="fc" id="L300">                    .and(markerPredicate)</span>
<span class="fc" id="L301">                    .and(keyValuePairsPredicate)</span>
<span class="fc" id="L302">                    .and(messagePredicate)</span>
<span class="fc" id="L303">                    .and(argumentsPredicate)</span>
<span class="fc" id="L304">                    .and(throwablePredicate)</span>
<span class="fc" id="L305">                    .and(mdcPredicate);</span>
        }
    }

    public static final class MdcComparator {

        /** Disables verification of the MDC contents. */
<span class="fc" id="L312">        public static final MdcComparator IGNORING = new MdcComparator((a, b) -&gt; true);</span>

        /**
         * Validates the contents of the MDC on the logging event exactly match the specified values.
         */
<span class="fc" id="L317">        public static final MdcComparator EXACT =</span>
<span class="pc bpc" id="L318" title="1 of 4 branches missed.">                new MdcComparator((a, b) -&gt; a.size() == b.size() &amp;&amp; a.entrySet().containsAll(b.entrySet()));</span>

        /**
         * Validates the MDC contains all specified entries, but will not fail if additional entries
         * exist.
         */
<span class="fc" id="L324">        public static final MdcComparator CONTAINING =</span>
<span class="fc" id="L325">                new MdcComparator((a, b) -&gt; a.entrySet().containsAll(b.entrySet()));</span>

        private final BiPredicate&lt;Map&lt;String, String&gt;, Map&lt;String, String&gt;&gt; compareFunction;

<span class="fc" id="L329">        private MdcComparator(BiPredicate&lt;Map&lt;String, String&gt;, Map&lt;String, String&gt;&gt; compareFunction) {</span>
<span class="fc" id="L330">            this.compareFunction = compareFunction;</span>
<span class="fc" id="L331">        }</span>

        public boolean compare(Map&lt;String, String&gt; actual, Map&lt;String, String&gt; expected) {
<span class="fc" id="L334">            return compareFunction.test(actual, expected);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>