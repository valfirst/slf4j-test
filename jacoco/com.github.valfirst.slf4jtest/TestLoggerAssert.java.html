<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TestLoggerAssert.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">SLF4J Test</a> &gt; <a href="index.source.html" class="el_package">com.github.valfirst.slf4jtest</a> &gt; <span class="el_source">TestLoggerAssert.java</span></div><h1>TestLoggerAssert.java</h1><pre class="source lang-java linenums">package com.github.valfirst.slf4jtest;

import com.google.common.collect.ObjectArrays;
import java.util.*;
import java.util.function.BiFunction;
import java.util.function.Predicate;
import org.slf4j.Marker;
import uk.org.lidalia.slf4jext.Level;

/**
 * A set of assertions to validate that logs have been logged to a {@link TestLogger}.
 *
 * &lt;p&gt;Should be thread safe, as this uses &lt;code&gt;testLogger.getLoggingEvents()&lt;/code&gt; by default. The
 * assertion mode can be switched to use &lt;code&gt;testLogger.getAllLoggingEvents()&lt;/code&gt; by calling
 * {@link #anyThread()}.
 */
public class TestLoggerAssert extends AbstractTestLoggerAssert&lt;TestLoggerAssert&gt; {

<span class="fc" id="L19">    private MdcComparator mdcComparator = MdcComparator.EXACT;</span>

    protected TestLoggerAssert(TestLogger testLogger) {
<span class="fc" id="L22">        super(testLogger, TestLoggerAssert.class);</span>
<span class="fc" id="L23">    }</span>

    /**
     * Changes the assertion mode to verify that log messages have been logged regardless of which
     * thread actually logged the message.
     *
     * @return a {@link TestLoggerAssert} for chaining
     */
    public TestLoggerAssert anyThread() {
<span class="fc" id="L32">        loggingEventsSupplier = actual::getAllLoggingEvents;</span>
<span class="fc" id="L33">        return this;</span>
    }

    /**
     * Allows the comparison strategy for verifying the MDC contents to be configured.
     *
     * &lt;p&gt;The default behaviour is to verify the contents of the MDC are exactly equal to those on the
     * logging event.
     *
     * @param mdcComparator the comparator to use when verifying the contents of the MDC captured by
     *     the logging event
     * @return a {@link TestLoggerAssert} for chaining
     * @see MdcComparator
     */
    public TestLoggerAssert usingMdcComparator(MdcComparator mdcComparator) {
<span class="fc" id="L48">        this.mdcComparator = mdcComparator;</span>
<span class="fc" id="L49">        return this;</span>
    }

    /**
     * Verify that a log message, at a specific level, has been logged by the test logger.
     *
     * @param level the level of the log message to look for
     * @param message the expected message
     * @param arguments any optional arguments that may be provided to the log message
     * @return a {@link TestLoggerAssert} for chaining
     */
    public TestLoggerAssert hasLogged(Level level, String message, Object... arguments) {
<span class="fc" id="L61">        return hasLogged(event(level, message, arguments));</span>
    }

    /**
     * Verify that a log message, at a specific level, has been logged by the test logger in the
     * presence of a {@link Throwable}.
     *
     * @param throwable the throwable that is attached to the log message
     * @param level the level of the log message to look for
     * @param message the expected message
     * @param arguments any optional arguments that may be provided to the log message
     * @return a {@link TestLoggerAssert} for chaining
     */
    public TestLoggerAssert hasLogged(
            Throwable throwable, Level level, String message, Object... arguments) {
<span class="fc" id="L76">        return hasLogged(event(throwable, level, message, arguments));</span>
    }

    /**
     * Verify that a {@link LoggingEvent} has been logged by the test logger.
     *
     * @param event the event to verify presence of
     * @return a {@link TestLoggerAssert} for chaining
     */
    public TestLoggerAssert hasLogged(LoggingEvent event) {
<span class="fc" id="L86">        return hasLogged(buildPredicate(event), &quot;Failed to find event:%n  %s&quot;, event);</span>
    }

    /**
     * Verify that a {@link LoggingEvent} satisfying the provided predicate has been logged by the
     * test logger.
     *
     * @param predicate the predicate to test against
     * @return a {@link TestLoggerAssert} for chaining
     */
    public TestLoggerAssert hasLogged(Predicate&lt;LoggingEvent&gt; predicate) {
<span class="fc" id="L97">        return hasLogged(predicate, &quot;Failed to find log matching predicate&quot;);</span>
    }

    /**
     * Verify that a log message, at a specific level, has not been logged by the test logger.
     *
     * @param level the level of the log message to look for
     * @param message the expected message
     * @param arguments any optional arguments that may be provided to the log message
     * @return a {@link TestLoggerAssert} for chaining
     */
    public TestLoggerAssert hasNotLogged(Level level, String message, Object... arguments) {
<span class="fc" id="L109">        return hasNotLogged(event(level, message, arguments));</span>
    }

    /**
     * Verify that a log message, at a specific level, has not been logged by the test logger in the
     * presence of a {@link Throwable}.
     *
     * @param throwable the throwable that is attached to the log message
     * @param level the level of the log message to look for
     * @param message the expected message
     * @param arguments any optional arguments that may be provided to the log message
     * @return a {@link TestLoggerAssert} for chaining
     */
    public TestLoggerAssert hasNotLogged(
            Throwable throwable, Level level, String message, Object... arguments) {
<span class="fc" id="L124">        return hasNotLogged(event(throwable, level, message, arguments));</span>
    }

    /**
     * Verify that a {@link LoggingEvent} has not been logged by the test logger.
     *
     * @param event the event to verify absence of
     * @return a {@link TestLoggerAssert} for chaining
     */
    public TestLoggerAssert hasNotLogged(LoggingEvent event) {
<span class="fc" id="L134">        return hasNotLogged(buildPredicate(event));</span>
    }

    /**
     * Verify that a {@link LoggingEvent} satisfying the provided predicate has _not_ been logged by
     * the test logger.
     *
     * @param predicate the predicate to test against
     * @return a {@link TestLoggerAssert} for chaining
     */
    public TestLoggerAssert hasNotLogged(Predicate&lt;LoggingEvent&gt; predicate) {
<span class="fc" id="L145">        findEvent(predicate)</span>
<span class="fc" id="L146">                .ifPresent(</span>
                        loggingEvent -&gt;
<span class="nc" id="L148">                                failWithMessage(&quot;Found %s, even though we expected not to&quot;, loggingEvent));</span>

<span class="fc" id="L150">        return this;</span>
    }

    /**
     * Convenience method for a {@link LevelAssert} from a provided test logger.
     *
     * @param level the {@link Level} to assert against
     * @return the {@link LevelAssert} bound to the given {@link Level}
     */
    public LevelAssert hasLevel(Level level) {
<span class="fc" id="L160">        LevelAssert levelAssert = new LevelAssert(actual, level);</span>
<span class="fc" id="L161">        levelAssert.loggingEventsSupplier = loggingEventsSupplier;</span>
<span class="fc" id="L162">        return levelAssert;</span>
    }

    private TestLoggerAssert hasLogged(
            Predicate&lt;LoggingEvent&gt; predicate, String failureMessage, Object... arguments) {
<span class="fc bfc" id="L167" title="All 2 branches covered.">        if (!findEvent(predicate).isPresent()) {</span>
<span class="fc" id="L168">            String allEvents =</span>
<span class="fc" id="L169">                    loggingEventsSupplier.get().stream()</span>
<span class="fc" id="L170">                            .map(Objects::toString)</span>
<span class="fc" id="L171">                            .reduce((first, second) -&gt; first + &quot;\n  - &quot; + second)</span>
<span class="fc" id="L172">                            .map(output -&gt; &quot;  - &quot; + output)</span>
<span class="fc" id="L173">                            .orElse(&quot;  &lt;none&gt;&quot;);</span>
<span class="fc" id="L174">            Object[] newArguments = ObjectArrays.concat(arguments, allEvents);</span>
<span class="nc" id="L175">            failWithMessage(</span>
                    failureMessage + &quot;%n%nThe logger contained the following events:%n%s&quot;, newArguments);
        }
<span class="fc" id="L178">        return this;</span>
    }

    private Predicate&lt;LoggingEvent&gt; buildPredicate(LoggingEvent event) {
<span class="fc" id="L182">        return new PredicateBuilder()</span>
<span class="fc" id="L183">                .withMarker(event.getMarker().orElse(null))</span>
<span class="fc" id="L184">                .withThrowable(event.getThrowable().orElse(null))</span>
<span class="fc" id="L185">                .withLevel(event.getLevel())</span>
<span class="fc" id="L186">                .withMessage(event.getMessage())</span>
<span class="fc" id="L187">                .withArguments(event.getArguments().toArray())</span>
<span class="fc" id="L188">                .withMdc(event.getMdc(), mdcComparator)</span>
<span class="fc" id="L189">                .build();</span>
    }

    private Optional&lt;LoggingEvent&gt; findEvent(Predicate&lt;LoggingEvent&gt; predicate) {
<span class="fc" id="L193">        return loggingEventsSupplier.get().stream().filter(predicate).findFirst();</span>
    }

<span class="fc" id="L196">    public static class PredicateBuilder {</span>

<span class="pc" id="L198">        private static final Predicate&lt;LoggingEvent&gt; IGNORE_PREDICATE = event -&gt; true;</span>

<span class="fc" id="L200">        private Predicate&lt;LoggingEvent&gt; messagePredicate = IGNORE_PREDICATE;</span>
<span class="fc" id="L201">        private Predicate&lt;LoggingEvent&gt; argumentsPredicate = IGNORE_PREDICATE;</span>
<span class="fc" id="L202">        private Predicate&lt;LoggingEvent&gt; markerPredicate = IGNORE_PREDICATE;</span>
<span class="fc" id="L203">        private Predicate&lt;LoggingEvent&gt; mdcPredicate = IGNORE_PREDICATE;</span>
<span class="fc" id="L204">        private Predicate&lt;LoggingEvent&gt; throwablePredicate = IGNORE_PREDICATE;</span>
<span class="fc" id="L205">        private Predicate&lt;LoggingEvent&gt; levelPredicate = IGNORE_PREDICATE;</span>

        public PredicateBuilder withLevel(Level level) {
<span class="fc" id="L208">            levelPredicate = event -&gt; event.getLevel().equals(level);</span>
<span class="fc" id="L209">            return this;</span>
        }

        public PredicateBuilder withMarker(Marker marker) {
<span class="fc" id="L213">            markerPredicate = event -&gt; event.getMarker().equals(Optional.ofNullable(marker));</span>
<span class="fc" id="L214">            return this;</span>
        }

        public PredicateBuilder withMessage(String message) {
<span class="fc" id="L218">            return withMessage(message::equals);</span>
        }

        public PredicateBuilder withMessage(Predicate&lt;String&gt; predicate) {
<span class="fc" id="L222">            this.messagePredicate = event -&gt; predicate.test(event.getMessage());</span>
<span class="fc" id="L223">            return this;</span>
        }

        public PredicateBuilder withArguments(Object... arguments) {
<span class="fc" id="L227">            return withArguments(actualArgs -&gt; actualArgs.equals(Arrays.asList(arguments)));</span>
        }

        public PredicateBuilder withArguments(Predicate&lt;Collection&lt;Object&gt;&gt; predicate) {
<span class="fc" id="L231">            this.argumentsPredicate = event -&gt; predicate.test(event.getArguments());</span>
<span class="fc" id="L232">            return this;</span>
        }

        public PredicateBuilder withThrowable(Throwable throwable) {
<span class="fc" id="L236">            return withThrowable(t -&gt; t.equals(Optional.ofNullable(throwable)));</span>
        }

        public PredicateBuilder withThrowable(Predicate&lt;Optional&lt;Throwable&gt;&gt; predicate) {
<span class="fc" id="L240">            this.throwablePredicate = event -&gt; predicate.test(event.getThrowable());</span>
<span class="fc" id="L241">            return this;</span>
        }

        public PredicateBuilder withMdc(Map&lt;String, String&gt; mdc, MdcComparator comparator) {
<span class="fc" id="L245">            this.mdcPredicate = event -&gt; comparator.compare(event.getMdc(), mdc);</span>
<span class="fc" id="L246">            return this;</span>
        }

        public Predicate&lt;LoggingEvent&gt; build() {
<span class="fc" id="L250">            return levelPredicate</span>
<span class="fc" id="L251">                    .and(markerPredicate)</span>
<span class="fc" id="L252">                    .and(messagePredicate)</span>
<span class="fc" id="L253">                    .and(argumentsPredicate)</span>
<span class="fc" id="L254">                    .and(throwablePredicate)</span>
<span class="fc" id="L255">                    .and(mdcPredicate);</span>
        }
    }

    public static final class MdcComparator {

        /** Disables verification of the MDC contents. */
<span class="fc" id="L262">        public static final MdcComparator IGNORING = new MdcComparator((a, b) -&gt; true);</span>

        /**
         * Validates the contents of the MDC on the logging event exactly match the specified values.
         */
<span class="fc" id="L267">        public static final MdcComparator EXACT =</span>
<span class="pc bpc" id="L268" title="1 of 4 branches missed.">                new MdcComparator((a, b) -&gt; a.size() == b.size() &amp;&amp; a.entrySet().containsAll(b.entrySet()));</span>

        /**
         * Validates the MDC contains all specified entries, but will not fail if additional entries
         * exist.
         */
<span class="fc" id="L274">        public static final MdcComparator CONTAINING =</span>
<span class="fc" id="L275">                new MdcComparator((a, b) -&gt; a.entrySet().containsAll(b.entrySet()));</span>

        private final BiFunction&lt;Map&lt;String, String&gt;, Map&lt;String, String&gt;, Boolean&gt; compareFunction;

        private MdcComparator(
<span class="fc" id="L280">                BiFunction&lt;Map&lt;String, String&gt;, Map&lt;String, String&gt;, Boolean&gt; compareFunction) {</span>
<span class="fc" id="L281">            this.compareFunction = compareFunction;</span>
<span class="fc" id="L282">        }</span>

        public boolean compare(Map&lt;String, String&gt; actual, Map&lt;String, String&gt; expected) {
<span class="fc" id="L285">            return compareFunction.apply(actual, expected);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>